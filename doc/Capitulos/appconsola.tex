\section{Aplicaciones de Consola}
Una aplicación de consola es un programa diseñado para ser usado a través de una interfaz de solo-texto como una terminal. El usuario normalmente usa el teclado y la pantalla para interactuar con el programa, a diferencia de los programas con interfaces gráficas en los que se usa el mouse, el teclado y la pantalla. Esta envia su salida a la consola y recibe la entrada a través de la misma.\\

En este capitulo se habla de la construcción de un framework que permite generar los comandos de invocación para las aplicaciones de consola utilizando los formularios web. Y se trata de un framework porque se ofrecen librerias y herramientas para la construcción de componentes creados por los mismos programadores de las aplicaciones o por terceros.

\subsection{Programación por componentes}
El framework explota la programación por componentes, la cual se basa en la extensibilidad, un requerimiento no funcional del software en donde la implementación toma a consideración un futuro crecimiento y cuya evaluación está determinada por la habilidad de extender el sistema y el esfuerzo que requiere para llevarlo a cabo sin tener que modificar el código fuente original. \\

Varios lenguajes de programación como C++, Java, Python, Lisp o incluso algunos de dominio específico (DSL), permiten extender su funcionalidad a través de la carga dinámica de componentes en tiempo de ejecución. Dichos componentes son denominados plugins. Resulta más fácil crearlos en lenguajes que no poseen un chequeo estático de tipos, puesto a que no se necesita crear una interfaz estricta o un contrato que estos deban cumplir.\\

De igual forma, para lograr que un software escrito en un lenguaje compilado y a veces carente de reflexión, posea un motor de plugins, se hace uso de una máquina virtual para un lenguaje script embebido o un dsl. Esta técnica ha sido ampliamente explotada por los desarrolladores de videojuegos puesto a que reduce el tiempo de compilación, permite obtener mayor flexibilidad al programar, permite reusar componentes y tiene la capacidad de hacer uso de la reflexión si esta se encuentra en el lenguaje de programación que se esté usando \cite{LuaWhereUsed} \cite{LuaUses}.\\

A pesar de las ventajas que tiene usar un lenguaje embebido, también existen desventajas como la dificultad para depurar errores en el código fuente, la falta de integración con el IDE y, ya que son lenguajes interpretados, el rendimiento es pobre porque la forma a la que se ajusta a la arquitectura del hardware no tiene como fin el rendimiento, sumado a que cada operación necesita un chequeo de tipos.\\

Un plugin es un componente de software reusable y configurable que puede ser dinámicamente usado por una aplicación con la finalidad de extender su funcionalidad.\\

Un ejemplo notable del uso de plugins es el del servidor de Minecraft “Bukkit”, este permite a los desarrolladores extender el juego haciendo uso de tres elementos: eventos, listeners y comandos. El programador sólo tiene que cumplir una interfaz definida en el servidor para que este cargue, en tiempo de ejecución, el plugin y modifique el funcionamiento del servidor sin afectar su core. También cabe destacar el éxito de aplicaciones como Emacs que tiene un pequeño core y sus funciones de alto nivel están implementadas en un lenguaje de extensión \cite{Stallman:1981:EEC:1159890.806466}. \\

Permitirle a terceros crear plugins de aplicaciones de consola ayudaría a que muchas de ellas puedan ser utilizadas por usuarios sin tener que inmiscuirse en los pormenores de los comandos que implican su invocación.

\subsection{Características de las aplicaciones de consola}

Para invocar una aplicación de consola se deben formar dos partes de un texto, una corresponde al nombre del ejecutable junto con su ruta y la otra a los argumentos que recibe dicha aplicación. La segunda parte es en realidad un conjunto de opciones (también llamadas banderas) y de argumentos que cobran significado una vez el programador decida qué hacer con ellos en su aplicación.
\begin{itemize}
\item Opciones o banderas: son argumentos explícitos o implícitos que llevan una etiqueta con sigo.
\item Argumentos: Son valores de entrada de un programa de los cuales no hace falta especificar su nombre.
\end{itemize}

Si la ejecución de un programa se pudiera ver como la aplicación de una función, entonces el nombre del programa corresponde al nombre de la función y sus argumentos se dividirán entre anotados (opciones) y no anotados (argumentos).\\

Un programador puede encargarse de identificar los argumentos y las opciones que recibe su aplicación pero ya de por sí existen numerosas librerías se han creado para tal fin. Existen en lenguajes como C y C++ (getopt, getlongopt), para Java (Apache CLI, argparse4j), para go (Gflags) y para nodejs (argparse).\\

Ya que existen numerosas formas de interpretarlos, en linux, el estándar POSIX POSIX.1-2008 define una sintaxis para los argumentos y opciones de un programa, en él, las opciones consisten en una letra minuscula precedida por un guión, en el cual se pueden reunir varias opcioes o pueden haber argumentos para esas opciones. \\

Algunas de las características que describen varias aplicaciones de reciben parametros por consola son mostradas a continuación.\\

\begin{table}
  \centering
\begin{tabular}{| p{7cm} | p{7cm}| }
\hline
Característica & Ejemplo
\\ \hline
Posicionales & docker run ubuntu /bin/bash
\\ \hline
Subcomando & git clone ULR O git pull origin master
\\ \hline
Un solo guión & tar -x hola.tar
\\ \hline
Doble guión & docker run --rm ubuntu /bin/bash
\\ \hline
Con ‘=’ de separación & gcc -std=standard
\\ \hline
Con ‘ ‘ (espacio) de separación & tar -x hola.tar
\\ \hline
Sin separación & gcc -I/usr/lib/openmpi
\\ \hline
Con opciones mutuamente excluyentes & Comando inválido: docker --rm -d ubuntu, ya que rm y d \newline no pueden ir al mismo tiempo
\\ \hline
Con opciones ‘agrupables’& tar -xvf hola.tar == tar -x -v -f hola.tar
\\ \hline
Con opciones booleanas (sin argumentos explícitos) & tar -xvf hola.tar
\\ \hline
Opciones con un solo argumento & docker build -t carlochess/tesis .
\\ \hline
Opciones con múltiples argumentos & curl --dns-servers 8.8.8.8 8.8.8.8
\\ \hline
Opciones con múltiples argumentos separadas por un token (‘;’ , ‘,’, ‘.’) &
java -cp jar1:jar2:jar3:dir1:. HelloWorld
\\ \hline
Opciones con alias & tar -cvf tar.tar folder \newline ó \newline tar --create --verbose --file=tar.tar folder
\\ \hline
Opciones sensibles a mayúsculas & sbatch -D /tmp -d 1,21,44 job.bash
\\ \hline
  \end{tabular}
%\caption{Paired t-test of most common TF families for Pearson Correlations}
  \caption{Tipos de opciones.}
  \label{tab:tiposopts}
\end{table}

Las características anteriormente descritas pueden ser representadas usando el framework propuesto en esta tesis.

\subsection{Descripción del framework}

La tesis construye y propone un framework que permite a los programadores de aplicaciones y a terceros publicar una aplicación en portal web científico cuya interfaz es mas amigable con el usuario porque no expone la línea de comandos. Para ello se debe crear un archivo de javascript que, al ser evaluado crea una función cuya salida es un objeto que contenga el nombre de la aplicación, la ubicación del ejecutable, la versión del plugin, la descripción de la aplicación, si usa o no Docker, la imagen de docker y seguido de otros tres elementos importantes:

\begin{itemize}
\item Render: Se trata de un arreglo de opciones, argumentos o múltiples opciones que tiene como finalidad resolver el problema del orden, la estructura del comando y la presencia o no de elementos.
\item Validation: Se trata de una función que que recibe el arreglo bajo el mismo orden de ‘Render’ pero que contiene los valores para cada opción o argumento. Busca verificar si lo que ha ingresado el usuario es válido. Luego de obtener los valores de parte del usuario, es posible hacer una validación antes de transformarlas en el comando requerido. Validaciones de tipo (que el valor sea un número y no una cadena alfanumérica), validaciones de existencia, de límites, entre muchas otras. También ofrece una solución al problemas de las opciones mutuamente excluyentes, ya que se puede conocer si ambas se encuentran presentes. Esta función debe devolver un booleano: true o false.
\item Transformation: Se trata de una función que recibe el arreglo bajo el mismo orden de ‘Render’ pero que contiene los valores para cada opción o argumento. Ya de antemano se sabe que es válida puesto a que Validation lo ha confirmado. Tiene como finalidad representar los valores en una cadena según lo solicite la aplicación. La transformación resuelve numerosos problemas enunciados anteriormente. Luego de la validación, una aplicación puede exigir que sus argumentos se encuentren separados por coma, ya que a esta función se le inyecta un arreglo de valores entonces el programador del plugin puede crear una cadena con los valores separados por coma. O bien, si una opción
\end{itemize}

\subsection{Render}
El framework ofrece al programador cuatro tipos distinto de datos para opciones y tres para argumentos que pueden ser usados a conveniencia. Dichos tipos de datos se representaran de manera distinta en la interfaz web del portal web científico:

\begin{itemize}
\item Sin argumentos: si una opción prescinde de argumentos, el programador puede elegir este tipo de dato indicando el nombre, su representación, una descripción y el valor booleano si quiere que esté presente o no.
\item Con argumento: si una opción requiere de un argumento y este debe ser indicado por el usuario, el programador puede elegir este tipo de dato indicando el nombre, su representación, una descripción y el valor por defecto. Además puede optar por un textarea o un input text.
\item Con argumento de acuerdo a un dominio: si la opción exige un argumento dentro de un dominio (e.g. un grupo de nombres), el programador puede elegir este tipo de dato indicando el nombre, su representación, una breve descripción  y el valor por defecto.
\item Con argumentos: si la opción exige al menos un argumento o varios mas.el programador puede elegir este tipo de dato indicando el nombre, su representación, una breve descripción y un arreglo con los valores por defecto.
\end{itemize}

La diferencia entre un argumento y una opción radica en que, para la función de transformación, el primero es un arreglo de valores mientras que el segundo es un objeto.

\begin{itemize}
\item Con argumento: si una opción requiere de un argumento y este debe ser indicado por el usuario, el programador puede elegir este tipo de dato indicando el nombre, su representación, una descripción y el valor por defecto. Además puede optar por un textarea o un input text.
\item Con argumento de acuerdo a un dominio: si la opción exige un argumento dentro de un dominio (e.g. un grupo de nombres), el programador puede elegir este tipo de dato indicando el nombre, su representación, una breve descripción  y el valor por defecto.
\item Con argumentos: si la opción exige al menos un argumento o varios mas.el programador puede elegir este tipo de dato indicando el nombre, su representación, una breve descripción y un arreglo con los valores por defecto.
\end{itemize}

Ademas, multiples opciones pueden ser agrupadas para que sea el usuario quien decida si va o no y con qué valor.

\begin{figure}
\begin{lstlisting}
var optsmultiples = {
    opts : [opcion2,opcion3,opcion4],
    opciones : true,
    value : [opcion3,opcion4,opcion2]
}
\end{lstlisting}
\caption{Opciones multiples}
\end{figure}

\subsection{Generación de formularios}
El trabajo valioso del framework se centra en tomar el arreglo provisto por render, determinar si se trata de una opción, un argumento o una lista de opciones y crear formularios que representen este objeto.

\begin{table}[ht]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{| l | l | l |}
\hline
Elemento & Representación en el DOM de HTML & Se pueden agregar más elementos \\ \hline
Opción sin argumentos &  Label Checkbox & No
\\ \hline
Opción con un argumento & Label Inputex ó Textarea& No
\\ \hline
Opción  con un argumento según un dominio& Label Option& No
\\ \hline
Opción con multiples argumentos & Label Inputex& Si
\\ \hline
Un solo argumento & Label Inputtex ó Texarea& No
\\ \hline
Argumento según un dominio & label Option& No
\\ \hline
Con múltiples argumentos& Label Inputtex& Si
\\ \hline
Opciones multiples& Option& Si
\\ \hline
\end{tabular}
}
%\caption{Paired t-test of most common TF families for Pearson Correlations}
\end{table}

También agrega listeners para que cada cambio en los valores de los widgets se vea representado en los objetos de javascript.


Si se trata de una lista de opciones o de argumentos con múltiples valores, el framework además creará botones para que el usuario pueda agregar o eliminar elementos.


\subsection{Distribución e instalación de plugins}
Los scripts pueden ser distribuidos e instalados a través de los gestores de paquetes de javascript preferiblemente para front-end. Se sugiere usar Bower o Yarn para este problema.

\subsection{Carga dinámica}
La carga dinámica de estos scripts con previa autorización del administrador se realiza agregando el script al dom de la página web. Dicho script es descargado usando una petición ajax.

\begin{figure}
\begin{lstlisting}
var scriptTag = document.createElement('script');
scriptTag.src = url;
scriptTag.onload = implementationCode;
scriptTag.onreadystatechange = implementationCode;
document.body.appendChild(scriptTag);
\end{lstlisting}
\caption{Carga de plug-ins}
\end{figure}

\subsection{Programa para la obtención de opciones}
Una gran parte de los programas que son ejecutadas a través de una consola exponen un manual para los usuarios en donde se listan las opciones más importantes, su descripción, algunos ejemplos y un orden sugerido (“NAME”, “SYNOPSIS”, “DESCRIPTION”, “OPTIONS”, “SEE ALSO” and “AUTHOR”).
Son escritos en el procesador de documentos llamado groff y usualmente pueden ser consultados a través del comando de linux ‘man’. Son creadas manualmente por el documentador de la aplicación o pueden ser generadas automáticamente por el parser de opciones que incluye el programa.\\

Ya que el formato es libre, es difícil hallar de una manera simple las opciones sin embargo puede usarse la aplicación explainshell \cite{explainshell} para extraerlas y crear un código fuente inicial del plugin.
